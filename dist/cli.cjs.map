{"version":3,"sources":["../node_modules/.pnpm/tsup@8.5.0_postcss@8.5.6_typescript@5.8.3/node_modules/tsup/assets/cjs_shims.js","../src/yaml-parser.ts","../src/importers.ts","../src/cli.ts","../src/index.ts","../src/parser.ts","../src/exporters.ts","../src/utils/colors.ts","../src/utils/prompt.ts"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","import yaml from 'js-yaml'\nimport type { GrayMatterOption } from 'gray-matter'\n\n/**\n * Custom YAML parser that handles glob patterns starting with *\n * by pre-processing the YAML to quote unquoted strings that start with * during parsing\n * and removing quotes from glob patterns during stringification\n */\nexport function createSafeYamlParser() {\n  return {\n    parse: (str: string): object => {\n      // Pre-process the YAML string to quote glob patterns\n      // This regex looks for unquoted strings starting with * in YAML values\n      const processedStr = str.replace(\n        /^(\\s*\\w+:\\s*)(\\*[^\\n\\r\"']*?)(\\s*(?:\\r?\\n|$))/gm,\n        (match, prefix, value, suffix) => {\n          // Check if the value is already quoted\n          if (value.startsWith('\"') || value.startsWith(\"'\")) {\n            return match\n          }\n          // Quote the value to prevent it from being interpreted as a YAML alias\n          return `${prefix}\"${value}\"${suffix}`\n        }\n      )\n      \n      // Also handle array items that start with *\n      const fullyProcessedStr = processedStr.replace(\n        /^(\\s*-\\s+)(\\*[^\\n\\r\"']*?)(\\s*(?:\\r?\\n|$))/gm,\n        (match, prefix, value, suffix) => {\n          // Check if the value is already quoted\n          if (value.startsWith('\"') || value.startsWith(\"'\")) {\n            return match\n          }\n          // Quote the value\n          return `${prefix}\"${value}\"${suffix}`\n        }\n      )\n      \n      try {\n        return yaml.load(fullyProcessedStr) as object\n      } catch (error) {\n        // If preprocessing fails, try the original string\n        return yaml.load(str) as object\n      }\n    },\n    stringify: (data: object) => {\n      const yamlOutput = yaml.dump(data)\n      const lines = yamlOutput.split(/\\r?\\n/)\n      const out: string[] = []\n      let inGlobsArray = false\n      let globsIndent = ''\n      const containsGlob = (s: string) => s.includes('*')\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n\n        // Detect the globs key\n        const globsMatch = line.match(/^(\\s*)globs:\\s*(.*)$/)\n        if (globsMatch) {\n          globsIndent = globsMatch[1]\n          const value = globsMatch[2]\n\n          // Array style begins on next lines\n          if (value === '') {\n            inGlobsArray = true\n            out.push(line)\n            continue\n          }\n\n          // Scalar style on same line: globs: \"...\"\n          const scalar = value.match(/^(['\"])(.+)\\1(\\s*(?:#.*)?)$/)\n          if (scalar && containsGlob(scalar[2])) {\n            line = `${globsIndent}globs: ${scalar[2]}${scalar[3] ?? ''}`\n          }\n          out.push(line)\n          continue\n        }\n\n        if (inGlobsArray) {\n          // End of the globs array when we dedent\n          if (!line.startsWith(globsIndent + '  ')) {\n            inGlobsArray = false\n            i-- // reprocess this line outside array handling\n            continue\n          }\n          // Sequence item: - \"...\"\n          const item = line.match(/^(\\s*-\\s*)(['\"])(.+)\\2(\\s*(?:#.*)?)$/)\n          if (item && containsGlob(item[3])) {\n            line = `${item[1]}${item[3]}${item[4] ?? ''}`\n          }\n          out.push(line)\n          continue\n        }\n\n        out.push(line)\n      }\n      return out.join('\\n')\n    }\n  }\n}\n\n/**\n * Gray-matter options with custom YAML parser for handling glob patterns\n */\nexport const grayMatterOptions: GrayMatterOption<string, object> = {\n  engines: {\n    yaml: createSafeYamlParser()\n  }\n}","import { readFileSync, existsSync, readdirSync, statSync, Dirent } from 'fs'\nimport { join, basename } from 'path'\nimport matter from 'gray-matter'\nimport yaml from 'js-yaml'\nimport type { ImportResult, ImportResults, RuleBlock } from './types.js'\nimport { grayMatterOptions } from './yaml-parser.js'\n\n// Helper function to detect if a file/path indicates a private rule\nfunction isPrivateRule(filePath: string): boolean {\n  const lowerPath = filePath.toLowerCase()\n  return lowerPath.includes('.local.') || lowerPath.includes('/private/') || lowerPath.includes('\\\\private\\\\')\n}\n\nexport async function importAll(repoPath: string): Promise<ImportResults> {\n  const results: ImportResult[] = []\n  const errors: Array<{ file: string; error: string }> = []\n  \n  // Check for Agent directory (.agent/)\n  const agentDir = join(repoPath, '.agent')\n  if (existsSync(agentDir)) {\n    try {\n      results.push(importAgent(agentDir))\n    } catch (e) {\n      errors.push({ file: agentDir, error: String(e) })\n    }\n  }\n  \n  // Check for VS Code Copilot instructions\n  const copilotPath = join(repoPath, '.github', 'copilot-instructions.md')\n  if (existsSync(copilotPath)) {\n    try {\n      results.push(importCopilot(copilotPath))\n    } catch (e) {\n      errors.push({ file: copilotPath, error: String(e) })\n    }\n  }\n  \n  // Check for local VS Code Copilot instructions\n  const copilotLocalPath = join(repoPath, '.github', 'copilot-instructions.local.md')\n  if (existsSync(copilotLocalPath)) {\n    try {\n      results.push(importCopilot(copilotLocalPath))\n    } catch (e) {\n      errors.push({ file: copilotLocalPath, error: String(e) })\n    }\n  }\n  \n  // Check for Cursor directory (.cursor/)\n  const cursorDir = join(repoPath, '.cursor')\n  if (existsSync(cursorDir)) {\n    try {\n      results.push(importCursor(cursorDir))\n    } catch (e) {\n      errors.push({ file: cursorDir, error: String(e) })\n    }\n  }\n  \n  // Legacy single .cursorrules file\n  const cursorRulesFile = join(repoPath, '.cursorrules')\n  if (existsSync(cursorRulesFile)) {\n    try {\n      results.push(importCursorLegacy(cursorRulesFile))\n    } catch (e) {\n      errors.push({ file: cursorRulesFile, error: String(e) })\n    }\n  }\n  \n  // Check for Cline rules\n  const clinerules = join(repoPath, '.clinerules')\n  if (existsSync(clinerules)) {\n    try {\n      results.push(importCline(clinerules))\n    } catch (e) {\n      errors.push({ file: clinerules, error: String(e) })\n    }\n  }\n  \n  // Check for local Cline rules\n  const clinerulesLocal = join(repoPath, '.clinerules.local')\n  if (existsSync(clinerulesLocal)) {\n    try {\n      results.push(importCline(clinerulesLocal))\n    } catch (e) {\n      errors.push({ file: clinerulesLocal, error: String(e) })\n    }\n  }\n  \n  // Check for Windsurf rules\n  const windsurfRules = join(repoPath, '.windsurfrules')\n  if (existsSync(windsurfRules)) {\n    try {\n      results.push(importWindsurf(windsurfRules))\n    } catch (e) {\n      errors.push({ file: windsurfRules, error: String(e) })\n    }\n  }\n  \n  // Check for local Windsurf rules\n  const windsurfRulesLocal = join(repoPath, '.windsurfrules.local')\n  if (existsSync(windsurfRulesLocal)) {\n    try {\n      results.push(importWindsurf(windsurfRulesLocal))\n    } catch (e) {\n      errors.push({ file: windsurfRulesLocal, error: String(e) })\n    }\n  }\n  \n  // Check for Zed rules\n  const zedRules = join(repoPath, '.rules')\n  if (existsSync(zedRules)) {\n    try {\n      results.push(importZed(zedRules))\n    } catch (e) {\n      errors.push({ file: zedRules, error: String(e) })\n    }\n  }\n  \n  // Check for local Zed rules\n  const zedRulesLocal = join(repoPath, '.rules.local')\n  if (existsSync(zedRulesLocal)) {\n    try {\n      results.push(importZed(zedRulesLocal))\n    } catch (e) {\n      errors.push({ file: zedRulesLocal, error: String(e) })\n    }\n  }\n  \n  // Check for OpenAI Codex AGENTS.md\n  const agentsMd = join(repoPath, 'AGENTS.md')\n  if (existsSync(agentsMd)) {\n    try {\n      results.push(importCodex(agentsMd))\n    } catch (e) {\n      errors.push({ file: agentsMd, error: String(e) })\n    }\n  }\n  \n  // Check for local AGENTS.md\n  const agentsLocalMd = join(repoPath, 'AGENTS.local.md')\n  if (existsSync(agentsLocalMd)) {\n    try {\n      results.push(importCodex(agentsLocalMd))\n    } catch (e) {\n      errors.push({ file: agentsLocalMd, error: String(e) })\n    }\n  }\n  \n  // Check for CLAUDE.md (Claude Code)\n  const claudeMd = join(repoPath, 'CLAUDE.md')\n  if (existsSync(claudeMd)) {\n    try {\n      results.push(importClaudeCode(claudeMd))\n    } catch (e) {\n      errors.push({ file: claudeMd, error: String(e) })\n    }\n  }\n  \n  // Check for GEMINI.md (Gemini CLI)\n  const geminiMd = join(repoPath, 'GEMINI.md')\n  if (existsSync(geminiMd)) {\n    try {\n      results.push(importGemini(geminiMd))\n    } catch (e) {\n      errors.push({ file: geminiMd, error: String(e) })\n    }\n  }\n\n  // Check for best_practices.md (Qodo)\n  const bestPracticesMd = join(repoPath, 'best_practices.md')\n  if (existsSync(bestPracticesMd)) {\n    try {\n      results.push(importQodo(bestPracticesMd))\n    } catch (e) {\n      errors.push({ file: bestPracticesMd, error: String(e) })\n    }\n  }\n\n  // Check for local CLAUDE.md\n  const claudeLocalMd = join(repoPath, 'CLAUDE.local.md')\n  if (existsSync(claudeLocalMd)) {\n    try {\n      results.push(importClaudeCode(claudeLocalMd))\n    } catch (e) {\n      errors.push({ file: claudeLocalMd, error: String(e) })\n    }\n  }\n  \n  // Check for local GEMINI.md\n  const geminiLocalMd = join(repoPath, 'GEMINI.local.md')\n  if (existsSync(geminiLocalMd)) {\n    try {\n      results.push(importGemini(geminiLocalMd))\n    } catch (e) {\n      errors.push({ file: geminiLocalMd, error: String(e) })\n    }\n  }\n  \n  // Check for CONVENTIONS.md (Aider)\n  const conventionsMd = join(repoPath, 'CONVENTIONS.md')\n  if (existsSync(conventionsMd)) {\n    try {\n      results.push(importAider(conventionsMd))\n    } catch (e) {\n      errors.push({ file: conventionsMd, error: String(e) })\n    }\n  }\n  \n  // Check for local CONVENTIONS.md\n  const conventionsLocalMd = join(repoPath, 'CONVENTIONS.local.md')\n  if (existsSync(conventionsLocalMd)) {\n    try {\n      results.push(importAider(conventionsLocalMd))\n    } catch (e) {\n      errors.push({ file: conventionsLocalMd, error: String(e) })\n    }\n  }\n  \n  // Check for Amazon Q rules\n  const amazonqRulesDir = join(repoPath, '.amazonq', 'rules')\n  if (existsSync(amazonqRulesDir)) {\n    try {\n      results.push(importAmazonQ(amazonqRulesDir))\n    } catch (e) {\n      errors.push({ file: amazonqRulesDir, error: String(e) })\n    }\n  }\n  \n  return { results, errors }\n}\n\nexport function importCopilot(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const isPrivate = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: 'copilot-instructions',\n    alwaysApply: true,\n    description: 'GitHub Copilot custom instructions'\n  }\n  \n  if (isPrivate) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'copilot',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importAgent(agentDir: string): ImportResult {\n  const rules: RuleBlock[] = []\n  \n  // Recursively find all .md files in the agent directory\n  function findMarkdownFiles(dir: string, relativePath = ''): void {\n    const entries = readdirSync(dir, { withFileTypes: true })\n    \n    // Ensure deterministic ordering: process directories before files, then sort alphabetically\n    entries.sort((a: Dirent, b: Dirent) => {\n      if (a.isDirectory() && !b.isDirectory()) return -1;\n      if (!a.isDirectory() && b.isDirectory()) return 1;\n      return a.name.localeCompare(b.name);\n    })\n    \n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name)\n      const relPath = relativePath ? join(relativePath, entry.name) : entry.name\n      \n      if (entry.isDirectory()) {\n        // Recursively search subdirectories\n        findMarkdownFiles(fullPath, relPath)\n      } else if (entry.isFile() && entry.name.endsWith('.md')) {\n        const content = readFileSync(fullPath, 'utf-8')\n        const { data, content: body } = matter(content, grayMatterOptions)\n        \n        // Remove any leading numeric ordering prefixes (e.g., \"001-\" or \"12-\") from each path segment\n        let segments = relPath\n          .replace(/\\.md$/, '')\n          .replace(/\\\\/g, '/')\n          .split('/')\n          .map((s: string) => s.replace(/^\\d{2,}-/, '').replace(/\\.local$/, ''))\n        if (segments[0] === 'private') segments = segments.slice(1)\n        const defaultId = segments.join('/')\n        \n        // Check if this is a private rule (either by path or frontmatter)\n        const isPrivateFile = isPrivateRule(fullPath)\n        \n        const metadata: any = {\n          id: data.id || defaultId,\n          ...data\n        }\n        \n        // Set default alwaysApply to false if not specified\n        if (metadata.alwaysApply === undefined) {\n          metadata.alwaysApply = false\n        }\n        \n        // Only set private if it's true (from file pattern or frontmatter)\n        if (data.private === true || (data.private === undefined && isPrivateFile)) {\n          metadata.private = true\n        }\n        \n        rules.push({\n          metadata,\n          content: body.trim()\n        })\n      }\n    }\n  }\n  \n  findMarkdownFiles(agentDir)\n  \n  return {\n    format: 'agent',\n    filePath: agentDir,\n    rules\n  }\n}\n\nexport function importCursor(cursorDir: string): ImportResult {\n  const rules: RuleBlock[] = []\n  \n  // Recursively find all .mdc and .md files in the .cursor directory\n  function findCursorFiles(dir: string, relativePath = ''): void {\n    const entries = readdirSync(dir, { withFileTypes: true })\n    \n    // Ensure deterministic ordering: process directories before files, then sort alphabetically\n    entries.sort((a: Dirent, b: Dirent) => {\n      if (a.isDirectory() && !b.isDirectory()) return -1;\n      if (!a.isDirectory() && b.isDirectory()) return 1;\n      return a.name.localeCompare(b.name);\n    })\n    \n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name)\n      const relPath = relativePath ? join(relativePath, entry.name) : entry.name\n      \n      if (entry.isDirectory()) {\n        // Recursively search subdirectories\n        findCursorFiles(fullPath, relPath)\n      } else if (entry.isFile() && (entry.name.endsWith('.mdc') || entry.name.endsWith('.md'))) {\n        const content = readFileSync(fullPath, 'utf-8')\n        const { data, content: body } = matter(content, grayMatterOptions)\n        \n        // Remove any leading numeric ordering prefixes (e.g., \"001-\" or \"12-\") from each path segment\n        let segments = relPath\n          .replace(/\\.(mdc|md)$/, '')\n          .replace(/\\\\/g, '/')\n          .split('/')\n          .map((s: string) => s.replace(/^\\d{2,}-/, '').replace(/\\.local$/, ''))\n        \n        // Special handling for backward compatibility\n        if (segments[0] === 'private') segments = segments.slice(1)\n        // If the file is directly in the 'rules' directory, don't include 'rules' in the ID\n        if (segments[0] === 'rules' && segments.length === 2) segments = segments.slice(1)\n        \n        const defaultId = segments.join('/')\n        \n        // Check if this is a private rule\n        const isPrivateFile = isPrivateRule(fullPath)\n        \n        const metadata: any = {\n          id: data.id || defaultId,\n          ...data\n        }\n        \n        // Set default alwaysApply to false if not specified\n        if (metadata.alwaysApply === undefined) {\n          metadata.alwaysApply = false\n        }\n        \n        // Only set private if it's true (from file pattern or frontmatter)\n        if (data.private === true || (data.private === undefined && isPrivateFile)) {\n          metadata.private = true\n        }\n        \n        rules.push({\n          metadata,\n          content: body.trim()\n        })\n      }\n    }\n  }\n  \n  findCursorFiles(cursorDir)\n  \n  return {\n    format: 'cursor',\n    filePath: cursorDir,\n    rules\n  }\n}\n\nexport function importCursorLegacy(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const rules: RuleBlock[] = [{\n    metadata: {\n      id: 'cursor-rules-legacy',\n      alwaysApply: true,\n      description: 'Legacy Cursor rules'\n    },\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'cursor',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importCline(rulesPath: string): ImportResult {\n  const rules: RuleBlock[] = []\n  \n  // Check if it's a directory\n  if (existsSync(rulesPath) && statSync(rulesPath).isDirectory()) {\n    // Recursively find all .md files\n    function findMdFiles(dir: string, relativePath = ''): void {\n      const entries = readdirSync(dir, { withFileTypes: true })\n      \n      // Ensure deterministic ordering: process directories before files, then sort alphabetically\n      entries.sort((a: Dirent, b: Dirent) => {\n        if (a.isDirectory() && !b.isDirectory()) return -1;\n        if (!a.isDirectory() && b.isDirectory()) return 1;\n        return a.name.localeCompare(b.name);\n      })\n      \n      for (const entry of entries) {\n        const fullPath = join(dir, entry.name)\n        const relPath = relativePath ? join(relativePath, entry.name) : entry.name\n        \n        if (entry.isDirectory()) {\n          findMdFiles(fullPath, relPath)\n        } else if (entry.isFile() && entry.name.endsWith('.md')) {\n          const content = readFileSync(fullPath, 'utf-8')\n          const isPrivateFile = isPrivateRule(fullPath)\n          // Remove any leading numeric ordering prefixes (e.g., \"001-\" or \"12-\") from each path segment\n          let segments = relPath\n            .replace(/\\.md$/, '')\n            .replace(/\\\\/g, '/')\n            .split('/')\n            .map((s: string) => s.replace(/^\\d{2,}-/, '').replace(/\\.local$/, ''))\n          if (segments[0] === 'private') segments = segments.slice(1)\n          const defaultId = segments.join('/')\n          \n          const metadata: any = {\n            id: defaultId,\n            alwaysApply: true,\n            description: `Cline rules from ${relPath}`\n          }\n          \n          if (isPrivateFile) {\n            metadata.private = true\n          }\n          \n          rules.push({\n            metadata,\n            content: content.trim()\n          })\n        }\n      }\n    }\n    \n    findMdFiles(rulesPath)\n  } else {\n    // Single .clinerules file\n    const content = readFileSync(rulesPath, 'utf-8')\n    const isPrivateFile = isPrivateRule(rulesPath)\n    \n    const metadata: any = {\n      id: 'cline-rules',\n      alwaysApply: true,\n      description: 'Cline project rules'\n    }\n    \n    if (isPrivateFile) {\n      metadata.private = true\n    }\n    \n    rules.push({\n      metadata,\n      content: content.trim()\n    })\n  }\n  \n  return {\n    format: 'cline',\n    filePath: rulesPath,\n    rules\n  }\n}\n\nexport function importWindsurf(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const isPrivateFile = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: 'windsurf-rules',\n    alwaysApply: true,\n    description: 'Windsurf AI rules'\n  }\n  \n  if (isPrivateFile) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'windsurf',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importZed(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const isPrivateFile = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: 'zed-rules',\n    alwaysApply: true,\n    description: 'Zed editor rules'\n  }\n  \n  if (isPrivateFile) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'zed',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importCodex(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const format = basename(filePath) === 'AGENTS.md' || basename(filePath) === 'AGENTS.local.md' ? 'codex' : 'unknown'\n  const isPrivateFile = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: format === 'codex' ? 'codex-agents' : 'claude-rules',\n    alwaysApply: true,\n    description: format === 'codex' ? 'OpenAI Codex agent instructions' : 'Claude AI instructions'\n  }\n  \n  if (isPrivateFile) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format,\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importAider(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const isPrivateFile = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: 'aider-conventions',\n    alwaysApply: true,\n    description: 'Aider CLI conventions'\n  }\n  \n  if (isPrivateFile) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'aider',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importClaudeCode(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const isPrivateFile = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: 'claude-code-instructions',\n    alwaysApply: true,\n    description: 'Claude Code context and instructions'\n  }\n  \n  if (isPrivateFile) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'claude',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importGemini(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const isPrivateFile = isPrivateRule(filePath)\n  \n  const metadata: any = {\n    id: 'gemini-instructions',\n    alwaysApply: true,\n    description: 'Gemini CLI context and instructions'\n  }\n  \n  if (isPrivateFile) {\n    metadata.private = true\n  }\n  \n  const rules: RuleBlock[] = [{\n    metadata,\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'gemini',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importQodo(filePath: string): ImportResult {\n  const content = readFileSync(filePath, 'utf-8')\n  const rules: RuleBlock[] = [{\n    metadata: {\n      id: 'qodo-best-practices',\n      alwaysApply: true,\n      description: 'Qodo best practices and coding standards',\n      scope: '**/*',\n      priority: 'high'\n    },\n    content: content.trim()\n  }]\n  \n  return {\n    format: 'qodo',\n    filePath,\n    rules,\n    raw: content\n  }\n}\n\nexport function importAmazonQ(rulesDir: string): ImportResult {\n  const rules: RuleBlock[] = []\n  \n  // Recursively find all .md files in the Amazon Q rules directory\n  function findMdFiles(dir: string, relativePath = ''): void {\n    const entries = readdirSync(dir, { withFileTypes: true })\n    \n    // Ensure deterministic ordering: process directories before files, then sort alphabetically\n    entries.sort((a: Dirent, b: Dirent) => {\n      if (a.isDirectory() && !b.isDirectory()) return -1;\n      if (!a.isDirectory() && b.isDirectory()) return 1;\n      return a.name.localeCompare(b.name);\n    })\n    \n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name)\n      const relPath = relativePath ? join(relativePath, entry.name) : entry.name\n      \n      if (entry.isDirectory()) {\n        // Recursively search subdirectories\n        findMdFiles(fullPath, relPath)\n      } else if (entry.isFile() && entry.name.endsWith('.md')) {\n        const content = readFileSync(fullPath, 'utf-8')\n        const isPrivateFile = isPrivateRule(fullPath)\n        \n        // Remove any leading numeric ordering prefixes (e.g., \"001-\" or \"12-\") from each path segment\n        let segments = relPath\n          .replace(/\\.md$/, '')\n          .replace(/\\\\/g, '/')\n          .split('/')\n          .map((s: string) => s.replace(/^\\d{2,}-/, '').replace(/\\.local$/, ''))\n        if (segments[0] === 'private') segments = segments.slice(1)\n        const defaultId = segments.join('/')\n        \n        const metadata: any = {\n          id: `amazonq-${defaultId}`,\n          alwaysApply: true,\n          description: `Amazon Q rules from ${relPath}`\n        }\n        \n        if (isPrivateFile) {\n          metadata.private = true\n        }\n        \n        rules.push({\n          metadata,\n          content: content.trim()\n        })\n      }\n    }\n  }\n  \n  findMdFiles(rulesDir)\n  \n  return {\n    format: 'amazonq',\n    filePath: rulesDir,\n    rules\n  }\n}\n","#!/usr/bin/env node\n\nimport { existsSync, readFileSync, writeFileSync, appendFileSync, rmSync } from 'fs'\nimport { join, resolve, dirname } from 'path'\nimport { parseArgs } from 'util'\nimport { importAll, importAgent, exportToAgent, exportAll, exportToCopilot, exportToCursor, exportToCline, exportToWindsurf, exportToZed, exportToCodex, exportToAider, exportToClaudeCode, exportToGemini, exportToQodo } from './index.js'\nimport { color, header, formatList } from './utils/colors.js'\nimport { select, confirm } from './utils/prompt.js'\n\nconst { values, positionals } = parseArgs({\n  args: process.argv.slice(2),\n  options: {\n    help: { type: 'boolean', short: 'h' },\n    output: { type: 'string', short: 'o' },\n    format: { type: 'string', short: 'f' },\n    formats: { type: 'string' },\n    overwrite: { type: 'boolean', short: 'w' },\n    'dry-run': { type: 'boolean', short: 'd' },\n    'include-private': { type: 'boolean' },\n    'skip-private': { type: 'boolean' },\n    'no-gitignore': { type: 'boolean' },\n  },\n  allowPositionals: true\n}) as { values: any; positionals: string[] }\n\nfunction showHelp() {\n  console.log(`\n${color.bold('dotagent')} - Multi-file AI agent configuration manager\n\n${color.bold('Usage:')}\n  ${color.command('dotagent import')} ${color.dim('<repo-path>')}    Import all rule files from a repository\n  ${color.command('dotagent export')} ${color.dim('[repo-path]')}   Export .agent/ directory to all supported formats\n  ${color.command('dotagent convert')} ${color.dim('<file>')}        Convert a specific rule file\n\n${color.bold('Options:')}\n  ${color.yellow('-h, --help')}       Show this help message\n  ${color.yellow('-o, --output')}     Output file path (for convert command)\n  ${color.yellow('-f, --format')}     Specify format (copilot|cursor|cline|windsurf|zed|codex|aider|claude|gemini|qodo)\n  ${color.yellow('--formats')}        Specify multiple formats (comma-separated)\n  ${color.yellow('-w, --overwrite')}  Overwrite existing files\n  ${color.yellow('-d, --dry-run')}    Preview operations without making changes\n  ${color.yellow('--no-gitignore')}   Skip gitignore prompt\n\n${color.bold('Examples:')}\n  ${color.dim('# Import all rules from current directory (creates .agent/)')}\n  ${color.command('dotagent import .')}\n\n  ${color.dim('# Export .agent/ directory to all formats')}\n  ${color.command('dotagent export')}\n  \n  ${color.dim('# Export from specific directory')}\n  ${color.command('dotagent export /path/to/repo')}\n\n  ${color.dim('# Preview what would be imported without creating files')}\n  ${color.command('dotagent import . --dry-run')}\n`)\n}\n\nasync function main() {\n  if (values.help || positionals.length === 0) {\n    showHelp()\n    process.exit(0)\n  }\n\n  const command = positionals[0]\n  const target = positionals[1]\n  const isDryRun = values['dry-run']\n\n  if (isDryRun) {\n    console.log(color.info('Running in dry-run mode - no files will be modified'))\n  }\n\n  switch (command) {\n    case 'import': {\n      // Default to current directory if no target specified\n      const importTarget = target || '.'\n\n      const repoPath = resolve(importTarget)\n      if (!existsSync(repoPath)) {\n        console.error(color.error(`Path does not exist: ${color.path(repoPath)}`))\n        console.error(color.dim('Hint: Check if the path is correct or use \".\" for current directory'))\n        process.exit(1)\n      }\n\n      console.log(header('Importing Rules'))\n      console.log(`Scanning: ${color.path(repoPath)}`)\n      \n      const { results, errors } = await importAll(repoPath)\n\n      if (results.length === 0) {\n        console.log(color.warning('No rule files found'))\n        console.log(color.dim('Hint: DotAgent looks for:'))\n        console.log(formatList([\n          '.agent/**/*.md',\n          '.github/copilot-instructions.md',\n          '.cursor/**/*.{mdc,md}',\n          '.clinerules',\n          '.windsurfrules',\n          '.rules',\n          'AGENTS.md',\n          'CLAUDE.md',\n          'GEMINI.md',\n          'best_practices.md'\n        ]))\n      } else {\n        console.log(color.success(`Found ${color.number(results.length.toString())} rule file(s):`))\n        \n        for (const result of results) {\n          const ruleCount = color.number(`${result.rules.length} rule(s)`)\n          console.log(`  ${color.format(result.format)}: ${color.path(result.filePath)} ${color.dim(`(${ruleCount})`)}`)\n        }\n\n        // Combine all rules\n        const allRules = results.flatMap(r => r.rules)\n        \n        // Check if .agent directory exists\n        const agentDir = join(repoPath, '.agent')\n        if (existsSync(agentDir)) {\n          const existingAgent = importAgent(agentDir)\n          console.log(color.info(`Found existing .agent/ directory with ${color.number(existingAgent.rules.length.toString())} rule(s)`))\n        }\n\n        if (isDryRun) {\n          console.log(color.info(`Would export to: ${color.path(agentDir)}`))\n          console.log(color.dim(`Total rules: ${allRules.length}`))\n        } else {\n          const outputDir = values.output || repoPath\n          exportToAgent(allRules, outputDir)\n          console.log(color.success(`Created .agent/ directory with ${color.number(allRules.length.toString())} rule(s)`))\n        }\n      }\n\n      if (errors.length > 0) {\n        console.log(color.warning('Import errors:'))\n        for (const error of errors) {\n          console.log(`  ${color.red('Ã—')} ${color.path(error.file)}: ${error.error}`)\n        }\n      }\n      break\n    }\n\n    case 'export': {\n      // Default to current directory if no target specified\n      const repoPath = target ? resolve(target) : process.cwd()\n      const agentDir = join(repoPath, '.agent')\n      \n      if (!existsSync(agentDir)) {\n        console.error(color.error(`No .agent/ directory found in: ${color.path(repoPath)}`))\n        console.error(color.dim('Hint: Run \"dotagent import .\" first to create .agent/ directory'))\n        process.exit(1)\n      }\n\n      // Check for legacy .agentconfig file\n      const agentConfigPath = join(repoPath, '.agentconfig')\n      if (existsSync(agentConfigPath)) {\n        console.error(color.error('Found deprecated .agentconfig file'))\n        console.error(color.dim('The single-file .agentconfig format is deprecated. Please run \"dotagent import .\" to migrate to .agent/ directory.'))\n        process.exit(1)\n      }\n\n      console.log(header('Exporting Rules'))\n      \n      const result = importAgent(agentDir)\n      const rules = result.rules\n      \n      console.log(color.success(`Found ${color.number(rules.length.toString())} rule(s) in ${color.path(agentDir)}`))\n      \n      // Count private rules\n      const privateRuleCount = rules.filter(r => r.metadata.private).length\n      if (privateRuleCount > 0) {\n        console.log(color.dim(`Including ${privateRuleCount} private rule(s)`))\n      }\n\n      const outputDir = values.output || repoPath\n      \n      const exportFormats = [\n        { name: 'All formats', value: 'all' },\n        { name: 'VS Code Copilot (.github/copilot-instructions.md)', value: 'copilot' },\n        { name: 'Cursor (.cursor/rules/)', value: 'cursor' },\n        { name: 'Cline (.clinerules)', value: 'cline' },\n        { name: 'Windsurf (.windsurfrules)', value: 'windsurf' },\n        { name: 'Zed (.rules)', value: 'zed' },\n        { name: 'OpenAI Codex (AGENTS.md)', value: 'codex' },\n        { name: 'Aider (CONVENTIONS.md)', value: 'aider' },\n        { name: 'Claude Code (CLAUDE.md)', value: 'claude' },\n        { name: 'Gemini CLI (GEMINI.md)', value: 'gemini' },\n        { name: 'Qodo Merge (best_practices.md)', value: 'qodo' }\n      ]\n\n      // Handle format parameter or show interactive menu\n      let selectedFormats: string[] = []\n      \n      if (values.formats) {\n        // Parse comma-separated formats\n        selectedFormats = values.formats.split(',').map((f: string) => f.trim())\n      } else if (values.format) {\n        // Single format from -f flag\n        selectedFormats = [values.format]\n      } else {\n        // Interactive menu\n        console.log()\n        const selectedFormat = await select('Select export format:', exportFormats, 0)\n        selectedFormats = selectedFormat === 'all' ? ['all'] : [selectedFormat]\n      }\n\n      // Validate formats\n      const validFormats = ['all', 'copilot', 'cursor', 'cline', 'windsurf', 'zed', 'codex', 'aider', 'claude', 'gemini', 'qodo']\n      const invalidFormats = selectedFormats.filter(f => !validFormats.includes(f))\n      if (invalidFormats.length > 0) {\n        console.error(color.error(`Invalid format(s): ${invalidFormats.join(', ')}`))\n        console.error(color.dim(`Valid formats: ${validFormats.slice(1).join(', ')}, all`))\n        process.exit(1)\n      }\n      \n      if (isDryRun) {\n        console.log(color.info('Dry run mode - no files will be written'))\n      }\n      \n      const options = { includePrivate: values['include-private'] }\n      const exportedPaths: string[] = []\n      \n      // Handle multiple formats\n      for (const selectedFormat of selectedFormats) {\n        if (selectedFormat === 'all') {\n          if (!isDryRun) {\n            exportAll(rules, outputDir, false, options)\n          }\n          console.log(color.success('Exported to all formats'))\n          exportedPaths.push(\n            '.github/copilot-instructions.md',\n            '.cursor/rules/',\n            '.clinerules',\n            '.windsurfrules',\n            '.rules',\n            'AGENTS.md',\n            'CONVENTIONS.md',\n            'CLAUDE.md',\n            'GEMINI.md',\n            'best_practices.md'\n          )\n        } else {\n          // Export to specific format\n          let exportPath = ''\n          \n          switch (selectedFormat) {\n            case 'copilot':\n              exportPath = join(outputDir, '.github', 'copilot-instructions.md')\n              if (!isDryRun) exportToCopilot(rules, exportPath, options)\n              exportedPaths.push('.github/copilot-instructions.md')\n              break\n            case 'cursor':\n              if (!isDryRun) exportToCursor(rules, outputDir, options)\n              exportPath = join(outputDir, '.cursor/rules/')\n              exportedPaths.push('.cursor/rules/')\n              break\n            case 'cline':\n              exportPath = join(outputDir, '.clinerules')\n              if (!isDryRun) exportToCline(rules, exportPath, options)\n              exportedPaths.push('.clinerules')\n              break\n            case 'windsurf':\n              exportPath = join(outputDir, '.windsurfrules')\n              if (!isDryRun) exportToWindsurf(rules, exportPath, options)\n              exportedPaths.push('.windsurfrules')\n              break\n            case 'zed':\n              exportPath = join(outputDir, '.rules')\n              if (!isDryRun) exportToZed(rules, exportPath, options)\n              exportedPaths.push('.rules')\n              break\n            case 'codex':\n              exportPath = join(outputDir, 'AGENTS.md')\n              if (!isDryRun) exportToCodex(rules, exportPath, options)\n              exportedPaths.push('AGENTS.md')\n              break\n            case 'aider':\n              exportPath = join(outputDir, 'CONVENTIONS.md')\n              if (!isDryRun) exportToAider(rules, exportPath, options)\n              exportedPaths.push('CONVENTIONS.md')\n              break\n            case 'claude':\n              exportPath = join(outputDir, 'CLAUDE.md')\n              if (!isDryRun) exportToClaudeCode(rules, exportPath, options)\n              exportedPaths.push('CLAUDE.md')\n              break\n            case 'gemini':\n              exportPath = join(outputDir, 'GEMINI.md')\n              if (!isDryRun) exportToGemini(rules, exportPath, options)\n              exportedPaths.push('GEMINI.md')\n              break\n            case 'qodo':\n              exportPath = join(outputDir, 'best_practices.md')\n              if (!isDryRun) exportToQodo(rules, exportPath, options)\n              exportedPaths.push('best_practices.md')\n              break\n          }\n          \n          if (exportPath) {\n            console.log(color.success(`Exported to: ${color.path(exportPath)}`))\n          }\n        }\n      }\n      \n      if (!values['include-private'] && privateRuleCount > 0) {\n        console.log(color.dim(`\\nExcluded ${privateRuleCount} private rule(s). Use --include-private to include them.`))\n      }\n      \n      // Ask about gitignore unless --no-gitignore is specified\n      if (!isDryRun && exportedPaths.length > 0 && !values['no-gitignore']) {\n        console.log()\n        const shouldUpdateGitignore = await confirm('Add exported files to .gitignore?', true)\n        \n        if (shouldUpdateGitignore) {\n          updateGitignoreWithPaths(outputDir, exportedPaths)\n          console.log(color.success('Updated .gitignore'))\n        }\n      }\n      break\n    }\n\n    case 'convert': {\n      if (!target) {\n        console.error(color.error('Input file path required'))\n        process.exit(1)\n      }\n\n      const inputPath = resolve(target)\n      if (!existsSync(inputPath)) {\n        console.error(color.error(`File does not exist: ${color.path(inputPath)}`))\n        process.exit(1)\n      }\n\n      console.log(header('Converting File'))\n\n      // Auto-detect format or use specified\n      let format = values.format\n      if (!format) {\n        if (inputPath.includes('copilot-instructions')) format = 'copilot'\n        else if (inputPath.endsWith('.mdc')) format = 'cursor'\n        else if (inputPath.includes('.clinerules')) format = 'cline'\n        else if (inputPath.includes('.windsurfrules')) format = 'windsurf'\n        else if (inputPath.endsWith('.rules')) format = 'zed'\n        else if (inputPath.endsWith('AGENTS.md')) format = 'codex'\n        else if (inputPath.endsWith('CLAUDE.md')) format = 'claude'\n        else if (inputPath.endsWith('GEMINI.md')) format = 'gemini'\n        else if (inputPath.endsWith('CONVENTIONS.md')) format = 'aider'\n        else if (inputPath.endsWith('best_practices.md')) format = 'qodo'\n        else {\n          console.error(color.error('Cannot auto-detect format'))\n          console.error(color.dim('Hint: Specify format with -f (copilot|cursor|cline|windsurf|zed|codex|aider|claude|gemini|qodo)'))\n          process.exit(1)\n        }\n      }\n\n      console.log(`Format: ${color.format(format)}`)\n      console.log(`Input: ${color.path(inputPath)}`)\n\n      // Import using appropriate importer\n      const { importCopilot, importCursor, importCline, importWindsurf, importZed, importCodex, importAider, importClaudeCode, importGemini, importQodo } = await import('./importers.js')\n      \n      let result\n      switch (format) {\n        case 'copilot':\n          result = importCopilot(inputPath)\n          break\n        case 'cursor':\n          result = importCursor(inputPath)\n          break\n        case 'cline':\n          result = importCline(inputPath)\n          break\n        case 'windsurf':\n          result = importWindsurf(inputPath)\n          break\n        case 'zed':\n          result = importZed(inputPath)\n          break\n        case 'codex':\n          result = importCodex(inputPath)\n          break\n        case 'aider':\n          result = importAider(inputPath)\n          break\n        case 'claude':\n          result = importClaudeCode(inputPath)\n          break\n        case 'gemini':\n          result = importGemini(inputPath)\n          break\n        case 'qodo':\n          result = importQodo(inputPath)\n          break\n        default:\n          console.error(color.error(`Unknown format: ${format}`))\n          process.exit(1)\n      }\n\n      const outputDir = values.output || dirname(inputPath)\n      const agentDir = join(outputDir, '.agent')\n\n      // If an .agent directory already exists and overwrite flag is NOT set,\n      // remove it to ensure a clean conversion output. This prevents stale\n      // rules from previous operations (e.g., example workspaces) from\n      // contaminating the converted output and breaking ordering-sensitive tests.\n      if (existsSync(agentDir) && !values.overwrite) {\n        rmSync(agentDir, { recursive: true, force: true })\n      }\n\n      if (isDryRun) {\n        console.log(color.info(`Would export to: ${color.path(agentDir)}`))\n        console.log(color.dim(`Rules found: ${result.rules.length}`))\n      } else {\n        exportToAgent(result.rules, outputDir)\n        console.log(color.success(`Exported to: ${color.path(agentDir)}`))\n        console.log(color.dim(`Created ${result.rules.length} .mdc file(s)`))\n      }\n      break\n    }\n\n    default:\n      console.error(color.error(`Unknown command: ${command}`))\n      showHelp()\n      process.exit(1)\n  }\n}\n\nfunction updateGitignoreWithPaths(repoPath: string, paths: string[]): void {\n  const gitignorePath = join(repoPath, '.gitignore')\n  \n  const patterns = [\n    '',\n    '# Added by dotagent: ignore exported AI rule files',\n    ...paths.map(p => p.endsWith('/') ? p + '**' : p),\n    ''\n  ].join('\\n')\n  \n  if (existsSync(gitignorePath)) {\n    const content = readFileSync(gitignorePath, 'utf-8')\n    \n    // Check if any of the patterns already exist\n    const newPatterns = paths.filter(p => {\n      const pattern = p.endsWith('/') ? p + '**' : p\n      return !content.includes(pattern)\n    })\n    \n    if (newPatterns.length > 0) {\n      appendFileSync(gitignorePath, patterns)\n    }\n  } else {\n    writeFileSync(gitignorePath, patterns.trim() + '\\n')\n  }\n}\n\nfunction updateGitignore(repoPath: string): void {\n  const gitignorePath = join(repoPath, '.gitignore')\n  const privatePatterns = [\n    '# Added by dotagent: ignore private AI rule files',\n    '.agent/**/*.local.md',\n    '.agent/private/**',\n    '.github/copilot-instructions.local.md',\n    '.cursor/rules/**/*.local.{mdc,md}',\n    '.cursor/rules-private/**',\n    '.clinerules.local',\n    '.clinerules/private/**',\n    '.windsurfrules.local',\n    '.rules.local',\n    'AGENTS.local.md',\n    'CONVENTIONS.local.md',\n    'CLAUDE.local.md',\n    'GEMINI.local.md'\n  ].join('\\n')\n  \n  if (existsSync(gitignorePath)) {\n    const content = readFileSync(gitignorePath, 'utf-8')\n    \n    // Check if patterns are already present\n    if (!content.includes('# Added by dotagent:')) {\n      console.log(color.info('Updating .gitignore with private file patterns'))\n      appendFileSync(gitignorePath, '\\n\\n' + privatePatterns + '\\n', 'utf-8')\n    }\n  } else {\n    // Create new .gitignore\n    console.log(color.info('Creating .gitignore with private file patterns'))\n    writeFileSync(gitignorePath, privatePatterns + '\\n', 'utf-8')\n  }\n}\n\nmain().catch(error => {\n  console.error(color.error('Unexpected error:'))\n  console.error(error)\n  process.exit(1)\n})","export {\n  parseAgentMarkdown,\n  parseFenceEncodedMarkdown\n} from './parser.js'\n\nexport {\n  importAll,\n  importAgent,\n  importCopilot,\n  importCursor,\n  importCursorLegacy,\n  importCline,\n  importWindsurf,\n  importZed,\n  importCodex,\n  importAider,\n  importClaudeCode,\n  importGemini,\n  importQodo,\n  importAmazonQ\n} from './importers.js'\n\nexport {\n  toAgentMarkdown,\n  exportToAgent,\n  exportToCopilot,\n  exportToCursor,\n  exportToCline,\n  exportToWindsurf,\n  exportToZed,\n  exportToCodex,\n  exportToAider,\n  exportToClaudeCode,\n  exportToGemini,\n  exportToQodo,\n  exportToAmazonQ,\n  exportAll\n} from './exporters.js'\n\nexport type {\n  RuleMetadata,\n  RuleBlock,\n  ImportResult,\n  ImportResults,\n  ExportOptions,\n  ParserOptions\n} from './types.js'","import { unified } from 'unified'\nimport remarkParse from 'remark-parse'\nimport { toMarkdown } from 'mdast-util-to-markdown'\nimport yaml from 'js-yaml'\nimport type { Root, RootContent } from 'mdast'\nimport type { RuleBlock, RuleMetadata, ParserOptions } from './types.js'\n\n/**\n * @deprecated Use importAgent() instead. Single-file .agentconfig format is deprecated.\n */\nexport function parseAgentMarkdown(\n  markdown: string,\n  options: ParserOptions = {}\n): RuleBlock[] {\n  console.warn('Warning: parseAgentMarkdown() is deprecated. Use importAgent() to import from .agent/ directory instead.')\n  const processor = unified().use(remarkParse)\n  const tree = processor.parse(markdown) as Root\n\n  const rules: RuleBlock[] = []\n  let currentMetadata: RuleMetadata | null = null\n  let currentContent: RootContent[] = []\n  let currentPosition: RuleBlock['position'] | undefined\n\n  for (let i = 0; i < tree.children.length; i++) {\n    const node = tree.children[i]\n\n    // Check for HTML comment with @<id> directive\n    if (node.type === 'html' && isRuleComment(node.value)) {\n      // If we have accumulated content, save the previous rule\n      if (currentMetadata && currentContent.length > 0) {\n        rules.push({\n          metadata: currentMetadata,\n          content: nodesToMarkdown(currentContent),\n          position: currentPosition\n        })\n      }\n\n      // Parse the new metadata\n      currentMetadata = parseRuleComment(node.value)\n      currentContent = []\n      currentPosition = node.position ? {\n        start: { ...node.position.start },\n        end: { ...node.position.end }\n      } : undefined\n    }\n    // Accumulate content\n    else if (currentMetadata) {\n      currentContent.push(node)\n      if (currentPosition && node.position) {\n        currentPosition.end = { ...node.position.end }\n      }\n    }\n  }\n\n  // Don't forget the last rule\n  if (currentMetadata && currentContent.length > 0) {\n    rules.push({\n      metadata: currentMetadata,\n      content: nodesToMarkdown(currentContent),\n      position: currentPosition\n    })\n  }\n\n  return rules\n}\n\nfunction isRuleComment(html: string): boolean {\n  // Check if it contains @<id> pattern (@ followed by alphanumeric and hyphens)\n  return /<!--\\s*@[a-zA-Z0-9-]+(\\s|$)/.test(html)\n}\n\nfunction parseRuleComment(html: string): RuleMetadata {\n  // Extract @<id> and any additional metadata\n  const match = html.match(/<!--\\s*@([a-zA-Z0-9-]+)\\s*([\\s\\S]*?)\\s*-->/)\n  if (!match) {\n    throw new Error('Invalid rule comment format')\n  }\n\n  const id = match[1]\n  const metaContent = match[2].trim()\n\n  // Start with the ID from the @<id> pattern\n  const metadata: RuleMetadata = { id }\n\n  // If there's no additional content, return just the ID\n  if (!metaContent) {\n    return metadata\n  }\n\n  // Check if it looks like YAML (has newlines or starts with a YAML indicator)\n  if (metaContent.includes('\\n') || metaContent.startsWith('-') || metaContent.includes(': ')) {\n    // Try to parse as YAML\n    try {\n      const parsed = yaml.load(metaContent) as Record<string, unknown>\n      if (typeof parsed === 'object' && parsed !== null) {\n        // Merge with existing metadata, but preserve the ID from @<id>\n        return { ...parsed, id } as RuleMetadata\n      }\n    } catch {\n      // Fall through to key:value parsing\n    }\n  }\n\n  // Parse as key:value pairs\n  // First check if it's all on one line (inline format)\n  if (!metaContent.includes('\\n')) {\n    // Inline format: key:value pairs separated by spaces\n    const pairs = metaContent.matchAll(/(\\w+):(\\S+)(?:\\s|$)/g);\n    for (const [, key, value] of pairs) {\n      // Skip 'id' since we already have it from @<id>\n      if (key === 'scope' && value.includes(',')) {\n        metadata[key] = value.split(',').map(s => s.trim())\n      } else if (key === 'alwaysApply' || key === 'manual') {\n        metadata[key] = value === 'true'\n      } else if (key !== 'id') {\n        metadata[key] = value\n      }\n    }\n  } else {\n    // Multi-line format: one key:value per line\n    const lines = metaContent.split('\\n');\n    for (const line of lines) {\n      const colonIndex = line.indexOf(':');\n      if (colonIndex > 0) {\n        const key = line.substring(0, colonIndex).trim();\n        const value = line.substring(colonIndex + 1).trim();\n        \n        // Skip 'id' since we already have it from @<id>\n        if (key === 'scope' && value.includes(',')) {\n          metadata[key] = value.split(',').map(s => s.trim())\n        } else if (key === 'alwaysApply' || key === 'manual') {\n          metadata[key] = value === 'true'\n        } else if (key !== 'id' && value) {\n          metadata[key] = value\n        }\n      }\n    }\n  }\n\n  return metadata\n}\n\nfunction nodesToMarkdown(nodes: RootContent[]): string {\n  const tree: Root = {\n    type: 'root',\n    children: nodes\n  }\n\n  return toMarkdown(tree, {\n    bullet: '-',\n    emphasis: '*',\n    rule: '-'\n  }).trim()\n}\n\n// Alternative parser for fence-encoded format\nexport function parseFenceEncodedMarkdown(\n  markdown: string,\n  options: ParserOptions = {}\n): RuleBlock[] {\n  const processor = unified().use(remarkParse)\n  const tree = processor.parse(markdown) as Root\n\n  const rules: RuleBlock[] = []\n  let currentMetadata: RuleMetadata | null = null\n  let currentContent: RootContent[] = []\n  let currentPosition: RuleBlock['position'] | undefined\n\n  for (let i = 0; i < tree.children.length; i++) {\n    const node = tree.children[i]\n\n    // Check for code block with 'rule' language\n    if (node.type === 'code' && node.lang === 'rule') {\n      // Save previous rule if exists\n      if (currentMetadata && currentContent.length > 0) {\n        rules.push({\n          metadata: currentMetadata,\n          content: nodesToMarkdown(currentContent),\n          position: currentPosition\n        })\n      }\n\n      // Parse the rule metadata\n      try {\n        currentMetadata = yaml.load(node.value) as RuleMetadata\n        if (!currentMetadata.id) {\n          currentMetadata.id = `rule-${Date.now()}`\n        }\n        currentContent = []\n        currentPosition = node.position ? {\n          start: { ...node.position.start },\n          end: { ...node.position.end }\n        } : undefined\n      } catch (e) {\n        if (options.strict) {\n          throw new Error(`Failed to parse rule metadata: ${e}`)\n        }\n        // Skip invalid rule blocks in non-strict mode\n        currentMetadata = null\n      }\n    }\n    // Accumulate content after rule block\n    else if (currentMetadata) {\n      currentContent.push(node)\n      if (currentPosition && node.position) {\n        currentPosition.end = { ...node.position.end }\n      }\n    }\n  }\n\n  // Don't forget the last rule\n  if (currentMetadata && currentContent.length > 0) {\n    rules.push({\n      metadata: currentMetadata,\n      content: nodesToMarkdown(currentContent),\n      position: currentPosition\n    })\n  }\n\n  return rules\n}","import { writeFileSync, mkdirSync, existsSync } from 'fs'\nimport { join, dirname, relative } from 'path'\nimport yaml from 'js-yaml'\nimport matter from 'gray-matter'\nimport type { RuleBlock, ExportOptions } from './types.js'\nimport { grayMatterOptions } from './yaml-parser.js'\n\n/**\n * Generate conditional rules section for single-file formats\n */\nfunction generateConditionalRulesSection(rules: RuleBlock[], repoPath: string): string {\n  const sections: string[] = []\n  \n  // Separate rules by type\n  const alwaysApplyRules = rules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalRules = rules.filter(r => r.metadata.alwaysApply === false)\n  \n  if (conditionalRules.length === 0) {\n    return ''\n  }\n  \n  // Group rules by folder (e.g., workflows, components, etc.)\n  const rulesByFolder: Record<string, RuleBlock[]> = {}\n  const rulesWithScope: RuleBlock[] = []\n  const rulesWithDescription: RuleBlock[] = []\n  \n  conditionalRules.forEach(rule => {\n    // Extract folder from ID if it contains a slash\n    if (rule.metadata.id && rule.metadata.id.includes('/')) {\n      const folder = rule.metadata.id.split('/')[0]\n      if (!rulesByFolder[folder]) {\n        rulesByFolder[folder] = []\n      }\n      rulesByFolder[folder].push(rule)\n    }\n    \n    // Categorize by scope/description\n    if (rule.metadata.scope) {\n      rulesWithScope.push(rule)\n    } else if (rule.metadata.description && !rule.metadata.scope && !rule.metadata.id?.includes('/')) {\n      // Only treat as description-based if it's not in a folder\n      rulesWithDescription.push(rule)\n    }\n  })\n  \n  sections.push('## Context-Specific Rules')\n  sections.push('')\n  \n  // Add rules with scope patterns\n  if (rulesWithScope.length > 0) {\n    rulesWithScope.forEach(rule => {\n      const scopes = Array.isArray(rule.metadata.scope) ? rule.metadata.scope : [rule.metadata.scope]\n      scopes.forEach(scope => {\n        const rulePath = `.agent/${rule.metadata.id}.md`\n        const description = rule.metadata.description ? ` - ${rule.metadata.description}` : ''\n        sections.push(`When working with files matching \\`${scope}\\`, also apply:`)\n        sections.push(`â†’ [${rule.metadata.id}](${rulePath})${description}`)\n        sections.push('')\n      })\n    })\n  }\n  \n  // Add rules with description keywords\n  if (rulesWithDescription.length > 0) {\n    rulesWithDescription.forEach(rule => {\n      const rulePath = `.agent/${rule.metadata.id}.md`\n      sections.push(`When working with ${rule.metadata.description}, also apply:`)\n      sections.push(`â†’ [${rule.metadata.id}](${rulePath})`)\n      sections.push('')\n    })\n  }\n  \n  // Add folder-based sections (e.g., Workflows)\n  Object.entries(rulesByFolder).forEach(([folder, folderRules]) => {\n    // Skip if already handled above\n    const unhandledRules = folderRules.filter(r => \n      !rulesWithScope.includes(r) && !rulesWithDescription.includes(r)\n    )\n    \n    if (unhandledRules.length > 0) {\n      // Capitalize folder name for section title\n      const sectionTitle = folder.charAt(0).toUpperCase() + folder.slice(1)\n      sections.push(`## ${sectionTitle}`)\n      sections.push('')\n      \n      unhandledRules.forEach(rule => {\n        const rulePath = `.agent/${rule.metadata.id}.md`\n        const description = rule.metadata.description ? ` - ${rule.metadata.description}` : ''\n        sections.push(`â†’ [${rule.metadata.id}](${rulePath})${description}`)\n      })\n      sections.push('')\n    }\n  })\n  \n  return sections.join('\\n')\n}\n\n/**\n * @deprecated Use exportToAgent() instead. Single-file .agentconfig format is deprecated.\n */\nexport function toAgentMarkdown(rules: RuleBlock[]): string {\n  console.warn('Warning: toAgentMarkdown() is deprecated. Use exportToAgent() to export to .agent/ directory instead.')\n  \n  const sections: string[] = []\n\n  for (const rule of rules) {\n    const { metadata, content } = rule\n\n    // Extract id and other metadata\n    const { id, ...otherMetadata } = metadata\n\n    // Build the comment starting with @<id>\n    let metaComment = `<!-- @${id}`\n\n    // If there are other metadata properties, add them\n    if (Object.keys(otherMetadata).length > 0) {\n      // Format remaining metadata as YAML\n      const metaYaml = yaml.dump(otherMetadata, {\n        flowLevel: 1,\n        lineWidth: -1\n      }).trim()\n\n      metaComment += `\\n${metaYaml}`\n    }\n\n    metaComment += ' -->'\n\n    // Add section\n    sections.push(`${metaComment}\\n\\n${content}`)\n  }\n\n  return sections.join('\\n\\n')\n}\n\nexport function exportToCopilot(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  // Separate always-apply rules from conditional rules\n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  // Combine always-apply rules into main content\n  const mainContent = alwaysApplyRules\n    .map(rule => rule.content)\n    .join('\\n\\n---\\n\\n')\n  \n  // Add conditional rules section if there are any\n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n---\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToAgent(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void {\n  const agentDir = join(outputDir, '.agent')\n  mkdirSync(agentDir, { recursive: true })\n\n  let topIndex = 1;\n  rules.forEach(rule => {\n    // Support nested folders based on rule ID (e.g., \"api/auth\" -> \"api/auth.md\")\n    let filename: string\n    let filePath: string\n\n    if (rule.metadata.id && rule.metadata.id.includes('/')) {\n      // Create nested structure based on ID\n      const parts = rule.metadata.id.split('/')\n      const fileName = parts.pop() + '.md'\n      const subDir = join(agentDir, ...parts)\n      mkdirSync(subDir, { recursive: true })\n      filePath = join(subDir, fileName)\n    } else {\n      if (rule.metadata.private) {\n        const prefix = String(topIndex).padStart(3, '0') + '-'\n        topIndex++\n        filename = `${prefix}${rule.metadata.id || 'rule'}.md`\n        const privDir = join(agentDir, 'private')\n        mkdirSync(privDir, { recursive: true })\n        filePath = join(privDir, filename)\n      } else {\n        filename = `${rule.metadata.id || 'rule'}.md`\n        filePath = join(agentDir, filename)\n      }\n    }\n\n    // Prepare front matter data - filter out undefined and null values\n    const frontMatterBase: Record<string, unknown> = {}\n\n    if (rule.metadata.description !== undefined && rule.metadata.description !== null) frontMatterBase.description = rule.metadata.description\n    if (rule.metadata.alwaysApply !== undefined) frontMatterBase.alwaysApply = rule.metadata.alwaysApply\n    if (rule.metadata.globs !== undefined && rule.metadata.globs !== null) frontMatterBase.globs = rule.metadata.globs\n    if (rule.metadata.manual !== undefined && rule.metadata.manual !== null) frontMatterBase.manual = rule.metadata.manual\n    if (rule.metadata.scope !== undefined && rule.metadata.scope !== null) frontMatterBase.scope = rule.metadata.scope\n    if (rule.metadata.priority !== undefined && rule.metadata.priority !== null) frontMatterBase.priority = rule.metadata.priority\n    if (rule.metadata.triggers !== undefined && rule.metadata.triggers !== null) frontMatterBase.triggers = rule.metadata.triggers\n\n    // Add other metadata fields but exclude 'private' if it's false or null\n    for (const [key, value] of Object.entries(rule.metadata)) {\n      if (!['id', 'description', 'alwaysApply', 'globs', 'manual', 'scope', 'priority', 'triggers'].includes(key) && value !== undefined && value !== null) {\n        // Don't include private: false in frontmatter\n        if (key === 'private' && value === false) continue\n        frontMatterBase[key] = value\n      }\n    }\n\n    const frontMatter = frontMatterBase\n\n    // Create Markdown content with frontmatter\n    const mdContent = matter.stringify(rule.content, frontMatter, grayMatterOptions)\n    writeFileSync(filePath, mdContent, 'utf-8')\n  })\n}\n\nexport function exportToCursor(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void {\n  const rulesDir = join(outputDir, '.cursor', 'rules')\n  mkdirSync(rulesDir, { recursive: true })\n\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  for (const rule of filteredRules) {\n    // Support nested folders based on rule ID\n    let filePath: string\n    \n    if (rule.metadata.id && rule.metadata.id.includes('/')) {\n      // Create nested structure based on ID\n      const parts = rule.metadata.id.split('/')\n      const fileName = parts.pop() + '.mdc'\n      const subDir = join(rulesDir, ...parts)\n      mkdirSync(subDir, { recursive: true })\n      filePath = join(subDir, fileName)\n    } else {\n      const filename = `${rule.metadata.id || 'rule'}.mdc`\n      filePath = join(rulesDir, filename)\n    }\n\n    // Prepare front matter data - filter out undefined and null values\n    const frontMatterBase: Record<string, unknown> = {}\n\n    if (rule.metadata.description !== undefined && rule.metadata.description !== null) frontMatterBase.description = rule.metadata.description\n    if (rule.metadata.alwaysApply !== undefined) frontMatterBase.alwaysApply = rule.metadata.alwaysApply\n    if (rule.metadata.globs !== undefined && rule.metadata.globs !== null) frontMatterBase.globs = rule.metadata.globs\n    if (rule.metadata.manual !== undefined && rule.metadata.manual !== null) frontMatterBase.manual = rule.metadata.manual\n    if (rule.metadata.scope !== undefined && rule.metadata.scope !== null) frontMatterBase.scope = rule.metadata.scope\n    if (rule.metadata.priority !== undefined && rule.metadata.priority !== null) frontMatterBase.priority = rule.metadata.priority\n    if (rule.metadata.triggers !== undefined && rule.metadata.triggers !== null) frontMatterBase.triggers = rule.metadata.triggers\n\n    // Add other metadata fields but exclude 'private' if it's false or null\n    for (const [key, value] of Object.entries(rule.metadata)) {\n      if (!['id', 'description', 'alwaysApply', 'globs', 'manual', 'scope', 'priority', 'triggers'].includes(key) && value !== undefined && value !== null) {\n        // Don't include private: false in frontmatter\n        if (key === 'private' && value === false) continue\n        frontMatterBase[key] = value\n      }\n    }\n\n    const frontMatter = frontMatterBase\n\n    // Create MDC content\n    const mdcContent = matter.stringify(rule.content, frontMatter, grayMatterOptions)\n    writeFileSync(filePath, mdcContent, 'utf-8')\n  }\n}\n\nexport function exportToCline(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  if (outputPath.endsWith('.clinerules')) {\n    // Single file mode\n    const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n    const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n    \n    const mainContent = alwaysApplyRules\n      .map(rule => {\n        const header = rule.metadata.description ? `## ${rule.metadata.description}\\n\\n` : ''\n        return header + rule.content\n      })\n      .join('\\n\\n')\n    \n    const fullContent = conditionalSection \n      ? `${mainContent}\\n\\n${conditionalSection}`\n      : mainContent\n\n    ensureDirectoryExists(outputPath)\n    writeFileSync(outputPath, fullContent, 'utf-8')\n  } else {\n    // Directory mode\n    const rulesDir = join(outputPath, '.clinerules')\n    mkdirSync(rulesDir, { recursive: true })\n\n    filteredRules.forEach((rule, index) => {\n      const filename = `${String(index + 1).padStart(2, '0')}-${rule.metadata.id || 'rule'}.md`\n      const filePath = join(rulesDir, filename)\n      writeFileSync(filePath, rule.content, 'utf-8')\n    })\n  }\n}\n\nexport function exportToWindsurf(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  const mainContent = alwaysApplyRules\n    .map(rule => rule.content)\n    .join('\\n\\n')\n  \n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToZed(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  const mainContent = alwaysApplyRules\n    .map(rule => rule.content)\n    .join('\\n\\n')\n  \n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToCodex(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  const mainContent = alwaysApplyRules\n    .map(rule => {\n      const header = rule.metadata.description ? `# ${rule.metadata.description}\\n\\n` : ''\n      return header + rule.content\n    })\n    .join('\\n\\n')\n  \n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToAider(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  const mainContent = alwaysApplyRules\n    .map(rule => rule.content)\n    .join('\\n\\n')\n  \n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToClaudeCode(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  const mainContent = alwaysApplyRules\n    .map(rule => {\n      const header = rule.metadata.description ? `# ${rule.metadata.description}\\n\\n` : ''\n      return header + rule.content\n    })\n    .join('\\n\\n')\n  \n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToGemini(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const content = filteredRules\n    .map(rule => {\n      const header = rule.metadata.description ? `# ${rule.metadata.description}\\n\\n` : ''\n      return header + rule.content\n    })\n    .join('\\n\\n')\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, content, 'utf-8')\n}\n\nexport function exportToQodo(rules: RuleBlock[], outputPath: string, options?: ExportOptions): void {\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  const alwaysApplyRules = filteredRules.filter(r => r.metadata.alwaysApply !== false)\n  const conditionalSection = generateConditionalRulesSection(filteredRules, dirname(outputPath))\n  \n  const mainContent = alwaysApplyRules\n    .map(rule => {\n      const header = rule.metadata.description ? `# ${rule.metadata.description}\\n\\n` : ''\n      return header + rule.content\n    })\n    .join('\\n\\n---\\n\\n')\n  \n  const fullContent = conditionalSection \n    ? `${mainContent}\\n\\n---\\n\\n${conditionalSection}`\n    : mainContent\n\n  ensureDirectoryExists(outputPath)\n  writeFileSync(outputPath, fullContent, 'utf-8')\n}\n\nexport function exportToAmazonQ(rules: RuleBlock[], outputDir: string, options?: ExportOptions): void {\n  const rulesDir = join(outputDir, '.amazonq', 'rules')\n  mkdirSync(rulesDir, { recursive: true })\n\n  // Filter out private rules unless includePrivate is true\n  const filteredRules = rules.filter(rule => !rule.metadata.private || options?.includePrivate)\n  \n  for (const rule of filteredRules) {\n    // Support nested folders based on rule ID\n    let filePath: string\n    \n    if (rule.metadata.id && rule.metadata.id.includes('/')) {\n      // Create nested structure based on ID\n      const parts = rule.metadata.id.split('/')\n      const fileName = parts.pop() + '.md'\n      const subDir = join(rulesDir, ...parts)\n      mkdirSync(subDir, { recursive: true })\n      filePath = join(subDir, fileName)\n    } else {\n      // Clean up the ID by removing amazonq- prefix if present\n      const cleanId = rule.metadata.id?.startsWith('amazonq-') \n        ? rule.metadata.id.substring(8) \n        : rule.metadata.id || 'rule'\n      const filename = `${cleanId}.md`\n      filePath = join(rulesDir, filename)\n    }\n\n    // Amazon Q uses simple markdown format without frontmatter\n    writeFileSync(filePath, rule.content, 'utf-8')\n  }\n}\n\nexport function exportAll(rules: RuleBlock[], repoPath: string, dryRun = false, options: ExportOptions = { includePrivate: false }): void {\n  // Export to all supported formats\n  if (!dryRun) {\n    exportToAgent(rules, repoPath, options)\n    exportToCopilot(rules, join(repoPath, '.github', 'copilot-instructions.md'), options)\n    exportToCursor(rules, repoPath, options)\n    exportToCline(rules, join(repoPath, '.clinerules'), options)\n    exportToWindsurf(rules, join(repoPath, '.windsurfrules'), options)\n    exportToZed(rules, join(repoPath, '.rules'), options)\n    exportToCodex(rules, join(repoPath, 'AGENTS.md'), options)\n    exportToAider(rules, join(repoPath, 'CONVENTIONS.md'), options)\n    exportToClaudeCode(rules, join(repoPath, 'CLAUDE.md'), options)\n    exportToGemini(rules, join(repoPath, 'GEMINI.md'), options)\n    exportToQodo(rules, join(repoPath, 'best_practices.md'), options)\n    exportToAmazonQ(rules, repoPath, options)\n  }\n}\n\nfunction ensureDirectoryExists(filePath: string): void {\n  const dir = dirname(filePath)\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true })\n  }\n}","// ANSI color codes for terminal output\nconst colors = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  \n  // Foreground colors\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n  gray: '\\x1b[90m',\n  \n  // Background colors\n  bgRed: '\\x1b[41m',\n  bgGreen: '\\x1b[42m',\n  bgYellow: '\\x1b[43m',\n}\n\n// Check if colors are supported\nfunction supportsColor(): boolean {\n  if (process.env.NO_COLOR) return false\n  if (process.env.TERM === 'dumb') return false\n  if (process.env.COLORTERM) return true\n  if (process.env.TERM?.includes('color')) return true\n  // Default to false for safety in tests\n  return false\n}\n\nexport function colorize(text: string, color: keyof typeof colors): string {\n  if (!supportsColor()) return text\n  return `${colors[color]}${text}${colors.reset}`\n}\n\nexport const color = {\n  // Status messages\n  success: (text: string) => colorize(`âœ“ ${text}`, 'green'),\n  error: (text: string) => colorize(`âœ— ${text}`, 'red'),\n  warning: (text: string) => colorize(`âš  ${text}`, 'yellow'),\n  info: (text: string) => colorize(`â„¹ ${text}`, 'blue'),\n  \n  // Text formatting\n  bold: (text: string) => colorize(text, 'bright'),\n  dim: (text: string) => colorize(text, 'dim'),\n  \n  // Semantic colors\n  path: (text: string) => colorize(text, 'cyan'),\n  command: (text: string) => colorize(text, 'magenta'),\n  number: (text: string) => colorize(text, 'yellow'),\n  format: (text: string) => colorize(text, 'blue'),\n  \n  // Raw colors\n  red: (text: string) => colorize(text, 'red'),\n  green: (text: string) => colorize(text, 'green'),\n  yellow: (text: string) => colorize(text, 'yellow'),\n  blue: (text: string) => colorize(text, 'blue'),\n  gray: (text: string) => colorize(text, 'gray'),\n}\n\n// Helper for creating formatted lists\nexport function formatList(items: string[], prefix = '  '): string {\n  return items.map(item => `${prefix}${color.dim('â€¢')} ${item}`).join('\\n')\n}\n\n// Helper for creating a header\nexport function header(text: string): string {\n  const line = color.dim('â”€'.repeat(text.length + 4))\n  return `\\n${line}\\n${color.bold(`  ${text}  `)}\\n${line}\\n`\n}","import { select as inquirerSelect, confirm as inquirerConfirm } from '@inquirer/prompts'\n\nexport async function confirm(question: string, defaultValue = false): Promise<boolean> {\n  return await inquirerConfirm({\n    message: question,\n    default: defaultValue\n  })\n}\n\nexport async function select<T>(\n  message: string,\n  choices: Array<{ name: string; value: T }>,\n  defaultIndex = 0\n): Promise<T> {\n  // Convert to inquirer format\n  const inquirerChoices = choices.map((choice, index) => ({\n    name: choice.name,\n    value: choice.value,\n    // Set the default based on index\n    ...(index === defaultIndex ? { default: true } : {})\n  }))\n\n  return await inquirerSelect({\n    message,\n    choices: inquirerChoices\n  })\n}\n\n// Keep prompt function for backwards compatibility if needed\nexport async function prompt(question: string): Promise<string> {\n  // For now, we'll just throw an error if this is called\n  // since it's not used in the current codebase\n  throw new Error('prompt() is deprecated. Use select() or confirm() instead.')\n}"],"mappings":"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","names":["yaml","import_js_yaml","matter","findMdFiles","import_fs","import_path","import_fs","import_path","import_js_yaml","import_gray_matter","matter","header","color","inquirerConfirm","inquirerSelect","importCopilot","importCursor","importCline","importWindsurf","importZed","importCodex","importAider","importClaudeCode","importGemini","importQodo"]}